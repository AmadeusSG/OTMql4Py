<!DOCTYPE html>
<html>
<!-- This file is automatically generated: do not edit. -->
<head>
<title>Some Notes</title>
<meta charset="utf-8">
</head>
<body>
<!-- <h1>Some Notes</h1> -->
<p>These are some some notes from the original version of the source code.<br />
The points will be still valids, but the documentation needs updating.</p>

<h3>One Interpreter</h3>

<p>All expert advisors and indicators share the same Python interpreter<br />
with the same global namespace, so you should separate them by<br />
encapsulating all in classes and instantiate and store them with all<br />
their state in variables named after the symbol (or maybe even symbol<br />
+ timeframe). </p>

<h3>Init</h3>

<p>Put your Python classes into Python modules, the import path is<br />
<tt>&lt;metatrader&gt;\MQL4\Experts</tt>, the same folder where your EAs mql<br />
code is located, so a simple {{{vPyExecuteUnicode("import<br />
yourmodule");}}} in your <tt>OnInit()</tt> will import the file<br />
<tt>yourmodule.py</tt> from this folder.</p>

<p>Then instantiate an instance of your main class with something like</p>
<pre>
    vPyExecuteUnicode(Symbol() + Period() + " = yourmodule.yourclass()");
</pre>

<p>This way each instance of your EA can keep track of its own<br />
Python counterpart by accessing it via this global variable.</p>

<p>Your init() function may look similar to this:</p>
<pre>
int init(){
    // initialize Python
    PyInit();

    // import my module
    vPyExecuteUnicode("import mymodule");

    // instantiate some objects
    vPyExecuteUnicode("myFoo_" + Symbol() + Period() + " = mymodule.Foo()");
    vPyExecuteUnicode("myBar_" + Symbol() + Period() + " = mymodule.Bar()");

    return(0);
}
</pre>

<h3>OnDeinit</h3>

<p>Use the OnDeinit() function of the EA or Indicator to destroy<br />
these instances, be sure to terminate all threads they may have<br />
started, make sure you can terminate them fast within less than a<br />
second because Metatrader has a timeout here, wait inside python<br />
in a tight loop with time.sleep() until they are terminated before<br />
returning to prevent Metatrader from proceding with its OnDeinit<br />
while your threads are still not all ended!</p>

<p>Your OnDeinit() function may look like this:</p>
<pre>
int OnDeinit(){
    // tell my objects they should commit suicide by
    // calling their self destruction method
    vPyExecuteUnicode("myFoo_" + Symbol() + Period() + ".stopAndDestroy()");
    vPyExecuteUnicode("myBar_" + Symbol() + Period() + ".stopAndDestroy()");

    return(0);
}
</pre>

<h3>Global unload hook</h3>

<p>If the last EA that used Python has been removed the Python<br />
interpreter itself will be terminated and unloaded.</p>

<p>You can register cleanup functions (do it per imported module, not<br />
per instance!) with the Python <tt>atexit</tt> module, it will be called after the<br />
last EAs <tt>OnDeinit()</tt>, again as above make it wait for all cleaning<br />
action to be finished before returning, these are the last clock<br />
cycles that will be spent inside Python because at this time there<br />
is only one system thread left and if this function returns the<br />
python interpreter will be frozen and then immediately unloaded.</p>

<hr />

<p>Parent: <a href="ProjectHistory.html">ProjectHistory</a></p></body>
</html>
